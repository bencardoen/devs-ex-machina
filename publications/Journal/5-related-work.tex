Several similar \textsf{DEVS} simulation tools have already been implemented, though they differ in key aspects.
We discuss several dimensions of related work, as we try to compromise between different tools.

In terms of code design and philosophy, dxex is most related to PythonPDEVS~\cite{PythonPDEVS}.
Performance of PythonPDEVS was still decent, through the use of simulation and activity hints from the modeler.
This allowed the kernel to optimize its internal data structures and algorithms for the specific model being executed.
All changes were completely transparent to the model, and were completely optional.
In this spirit, we offer users the possibility to choose between different synchronization protocols.
This allows users to choose the most appropriate synchronization protocol, depending on the model.
Contrary to PythonPDEVS, however, dxex doesn't support distributed simulation, model migrations~\cite{PythonPDEVS2}, or activity hints~\cite{PythonPDEVS_ACTIMS}.

While PythonPDEVS offers very fast turnaround cycles, due to the use of an interpreted language, simulation performance was easily outdone by compiled simulation kernels.
In terms of performance, adevs~\cite{adevs} offered much faster simulation, at the cost of a significant compilation time.
The turnaround cycle in adevs is much slower though, specifically because the complete simulation kernel is implemented using templates in header files.
As a result, the complete simulation kernel has to be compiled again every time.
Dxex compromises, as vle~\cite{vle} or PowerDEVS~\cite{PowerDEVS}, by separating the simulation kernel into a shared library.
After the initial compilation of the simulation tool, only the model has to be compiled and linked to the library.
This significantly shortens the turnaround cycle, while still offering good performance.
In terms of performance, dxex is shown to be competitive with adevs.
Despite its high performance, adevs does not support optimistic synchronization, which we have shown to be highly relevant.

Previous \textsf{DEVS} simulation tools have already implemented multiple synchronization protocols, though none have done it in a strictly modular way that allows straightforward protocol switching for a single given model.
For example CD++~\cite{CD++} has both a conservative (CCD++~\cite{CCD++}) and optimistic (PCD++)~\cite{PCD++}) variant.
Despite the implementation of both protocols, they are different projects entirely, and are incompatible with modern compilers.
Dxex, on the other hand, is a single project, where switching between different synchronization protocols is as simple as switching any other configuration parameter.
CD++, however, implements both conservative and optimistic synchronization for distributed simulation, whereas we limit ourselves to parallel simulation.
By limiting our approach to parallel simulation, we are able to achieve higher speedups through the use of shared memory communication.


% Paragraph runtime switching
In the PDES community the problem of choosing between synchronization protocols is well known and documented \cite{Jha:1994:UFC:195291.182480}.
In the work of \cite{Das:1996:APP:256562.256602} the challenges facing the implementation of runtime switching between protocols is explored.
A PDES implementation of such a feature was presented in \cite{perumalla2005musik}. 
Our contribution entails bringing this feature to the PDEVS community.


% Paragraph allocation effects
Our emphasis on model allocation as a key factor in parallel performance has been studied in detail by the PDES community \cite{PDESpartitioning}. 
Referenced as partitioning of the simulation model, most studies distinguish between communication overhead and computational distribution (load balancing) as the two dimensions to partition over.
Partitioning a simulation model is identified as an issue in the work of \cite{Scalability} to achieve scalability. 
In \cite{PDEVSpartitioning} partitioning is studied in a PDEVS context with attention to load balancing and communication overhead.
Our contribution studies the effect of partitioning with emphasis on the effect of communication between processes and in the presence of a flattened hierarchy. 
We focus on static partitioning since this is a limiting factor for our conservative synchronization implementation which does not support model relocation.


In summary, dxex tries to find the middle ground between the concepts of PythonPDEVS, the performance of adevs, and the multiple synchronization protocols of CD++.
