\textsf{DEVS}~\cite{ClassicDEVS} is a popular formalism for modelling complex dynamic systems using a discrete-event abstraction.
In fact, it can serve as a simulation ``assembly language'' to which models in other formalisms can be mapped~\cite{DEVSbase}.
A number of tools have been constructed by academia and industry that allow the modelling and simulation of \textsf{DEVS} models.

But with the ever increasing complexity of simulation models, parallel simulation becomes necessary to perform the simulation within reasonable time bounds.
Whereas \textsf{Parallel DEVS}~\cite{ParallelDEVS} was introduced to increase parallelism, its inherent parallelism is often insufficient~\cite{Himmelspach}.
Several synchronization protocols from the discrete event simulation community~\cite{FujimotoBook} have been applied to \textsf{DEVS} simulation~\cite{globaltimewarp}.
Through synchronization protocols, different simulation cores can be at different points in simulated time, increasing parallelism significantly, at the cost of synchronization overhead.
While several parallel \textsf{DEVS} simulation kernels exist, they are often limited to a single synchronization protocol.
The reason for different synchronization protocols, however, is that their distinct nature makes them applicable in different situations, each outperforming the other in specific models~\cite{Jafer}.
The applicability of parallel simulation capabilities of current tools is therefore constrained to specific domains.

This paper introduces DEVS-Ex-Machina\footnote{\url{https://bitbucket.org/bcardoen/devs-ex-machina}} (``dxex''): our simulation tool~\cite{dxex} which offers multiple synchronization protocols: no synchronization (sequential execution), conservative synchronization, or optimistic synchronization.
The selected synchronization protocol is transparent to the simulated model: users only determine which protocol to use.
Users who simulate a wide variety of models, with different ideal synchronization protocols, can run the same model with different synchronization protocols.
Since the ideal synchronization protocol might change throughout the simulation, we also support runtime switching between these protocols.
This runtime switching is based on performance metrics, which are logged during simulation.
Information is made available to a seperate component, where a choice is made about which synchronization protocol to use next.
Additionally, we investigate in this paper how model allocation influences the performance of our synchronization protocols.
To this end, we have included an allocation component to our simulation kernel.

Our tool is based on PythonPDEVS, but implemented in C++11 for increased performance, using features from the new C++14 standard when supported by the compiler.
Unlike PythonPDEVS, dxex only supports multicore parallelism, thus no distributed simulation.

We implemented a model that, depending on a single parameter, changes its ideal synchronization protocol.
Using several models, we demonstrate the factors influencing the performance under a given synhronization protocol.
Dxex, then, is used to compare simulation using exactly the same tool, but with a varying synchronization protocol.
With dxex users can always opt to use the fastest protocol available, and through its modularity, users could even implement their own.
To verify that this modularity does not hinder performance, we compare to another Parallel DEVS simulation kernel, called adevs~\cite{adevs}.

%Usage of Hyperref with hardcoded label is hardly ideal, but ~\ref doesn't work if the layout disables numbered sections, so a hack is needed. The alternative is \nameref but that isn't all that readable.
The remainder of this paper is organized as follows:
Section~\textsc{\nameref{sec:2-background}} introduces the necessary background on synchronization protocols.
Section~\textsc{\nameref{sec:3-features}} elaborates on our design that enables this flexibility.
In Section~\textsc{\nameref{sec:4-performance}}, we evaluate performance of our tool by comparing its different synchronization protocols, and compare to adevs.
We continue by introducing runtime switching of synchronization protocols and different options for model allocation in Section~\textsc{\nameref{sec:4b-hotswap}} and Section~\textsc{\nameref{sec:4a-allocation}}, respectively.
Related work is discussed in Section~\textsc{\nameref{sec:5-related-work}}.
Section~\textsc{\nameref{sec:6-conclusion}} concludes the paper and gives future work.
