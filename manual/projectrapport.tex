\documentclass[8pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage{graphicx}
\usepackage[]{algorithm2e}

\title{Project Rapport\\\textsc{DEVS Ex Machina}}
\author{Ben Cardoen\\Pieter Lauwers\\Stijn Manhaeve\\Tim Tuijn\\Matthijs Van Os}
\date{}
\begin{document}
\maketitle
\tableofcontents{}

%
\chapter{Summary}
%
\section*{}
The project implements a C++ port of the PyPDEVS\cite{} project, extended with conservative synchronization and a change in system architecture from distributed simulation on several nodes (asymmetric mp) to an symmetric multiprocessing architecture. \\The summarized goal of the project is to provide an implementation of the offered DEVS paradigms with significantly lower execution time by levering the smp architecture.

\section*{Terminology}
The literature sometimes exchanges terms, to avoid any confusion the following frequent terms are listed with their associated meaning as used in this document:
\begin{itemize}
  \item Core : alias kernel. Single instance, containing a set of models it is responsible for, exchanges messages generated by those models and keeps time state. Can correspond with Logical Process in terms of what it represents.
  \item Logical Process : set of models with strong internal coherence.
  \item Distributed parallellism : computation distributed over several physically separated machines communicating by means of a network stack.
  \item SMP : symmetric multiprocessing, running a parallell computation on several distinct CPU cores/threads on the same machine with shared memory (and/or cache).
  \item message : any exchange of high level information between entities, user defined or for inter-kernel synchronization.
\end{itemize}

\chapter{Planning}
\section{Parallell}
\begin {itemize}
\item GVT integration : week 0-1, Ben and Tim
\item Conservative : week 2-3 , Ben and Tim
\end {itemize}
\section{General}
\begin {itemize}
\item Dynamic Structured : week 0-4 Stijn
\item DevStone and examples : week 0-4 Matthijs
\item ......
\end {itemize}

\chapter{Architecture Analysis}
\section{Implementation language}
Python is a very powerful language, but due to its interpreted nature it suffers from a performance point of view. Python's GIL \cite{} makes this issue even more serious whenever multithreading is required. Allthough it relieves the developer from tracking resource allocation, this comes at a price in the overhead caused by the GC. \\
In contrast, C++ offers low-level powerful thread primitives, but requires the developer to have a very deep understanding of parallell programming techniques. By using RAII, a C++ developer can leverage safe resource (de)allocation without losing performance.\\
A significant advantage Python offers a developer is relative cross-platform capability. This is non-trivial for a C++ developer, since at the very least the toolchains will be radically different in usage, and sometimes in implementation of the C++ standard. The edit-build-test cycle is also non-trivial for a large C++ application, whereas in Python this is negligible. In contrast, Python does not offer the programmer any of the C++ compiler's many compile time checks (static typechecks and program analysis).
\section{PyPDEVS analysis}
The PyPDEVS source code, partly due to Python's lax restrictions, violates a number of software design constraints. Not declaring attributes up until the point where they are needed (and not documenting them) makes for hard to read source code. The principle of encapsulation is rarely used throughout the Python code, for example the Solver class can freely swap out states from a model, forcing the classes to be bound tightly together. \\ % TODO add diplomacy
Python allows constructs such as self.content = ... , where contents type can be literally anything at runtime, something that is (without resorting to void*) impossible in C++. It also removes any protection from implementation mistakes.

\chapter{Design}
\section{Overview}
We chose early on to port the simulator by departing from the PyPDEVS implementation and creating a new structure, though keeping intact the structure in terms of functionality and interaction. Each class would use encapsulation to the fullest degree possible, and would be responsible only for task/functionality that belonged together. As an example, the C++ Core class is only responsible for driving the actual simulation steps (gathering messages, keeping time and transitioning models). It nevers interferes with modelstates (and thus needs no access whatsoever to those classes). A model is fully responsible for it's states and transitions, but beyond that has no state. A Controller combines both to create instances of the DEVS paradigms as and when needed, and provides a high level user interface (simulation control).

\section{Translating Dynamic Typing to Static Typing}
To represent objects that can be at runtime any type chosen by the user, we had 2 options : void* which is highly fragile in use, and impossible to serialize, or std::string(), which can double as an "anytype" by storing a serialized object inside the string, should this be required. This leaves the same degree of freedom dynamic typing grants to the user in PyPDEVS, with the added benefit of some checking provided by the compiler. Consider for example a user who stores an object serialized into the payload string of a message object, the compiler can in advance detect if the serializing object is at least serializable. Since these objects are not used by the kernel itself, the risk to corruption is minized, which is not the case should void* be used.

\section{Class decomposition}
The active entities in the project were discovered using several methods: use cases, role playing, argumentation and countargumentation and studying the existing implementation. This led to the following simplified decomposition:
\\ Model : provides DEVS paradigm implementation, hide details for user defined subclasses
\\ Core : drives transitions, exchanges messages, synchronizes
\\ Controller : Constructs simulator, controls simulation
\\ Tracer : Traces output
The other classes bind/create instances of the above (e.g. LocationTable, Allocator, Factory), or provide essential functionality (e.g. Message, Network, Scheduler)

\section{Network -- Kernel communication}
PyPDEVS uses MPI to exchange messages between kernels, whereas we could use shared memory to communicate between kernels (each running on 1 or more threads). We created a network architecture mimicking the approach used by PyPDEVS, without sacrificing the speed and ordering advantages of shared memory. The Network class consists of a single locked receiving port, and has for each existing kernel an outgoing queue. Receiving a message locks the network for the time it needs to place it on an integer indexed queue (very fast). If a kernel wants to receive messages it can do so if/when it is ready to do so, this only locks if at the same time a message is being received by the network. Several kernels can pull messages lockfree in parallel from the network (since the output queues are not shared). Early benchmarks made a throughput of 5e6 msg/s repeatable, with 4 kernels on modest hardware. The problems of (unintentional) out of order receipt and potential loss of messages is a non-issue in this context, since we use FIFO queues and loss of a message would implicate severe system failure (in which case message loss is the lesser problem).\\
Another advantage of hiding the message exchange behind a shared Network class instance is that, should this be required in the future, the kernel could run on different machines without requiring much redesigning of the system. An RPC implementation would simply have to implement the Network class on both sides.

\section{Tracing}
%TODO Stijn

\section{Models}
%TODO Tim

\section{Scheduler}
%TODO Ben

\section{Controller}
%TODO Matthijs

\section{Serialization}
%TODO Pieter

\chapter{Implementation}
\section{Correctness}
\subsubsection{Testing}
The use of the jenkins CI was heavily leveraged, in combination with extensive testing. Any feauture increment could only be merged into the project if it passed the developer's own jenkins instance.
\subsubsection{Thread races and deadlock}
Deadlocks and race conditions are very hard to debug, let alone prevent. To help us in this area as much as possible we used prototypes of threaded code in the tests before merging them into the main Classes, and each build is checked with ThreadSanitizer \cite{} which proved invaluable in preventing races and deadlocks in the threaded codepaths.
\subsubsection{Memory leaks and undefined behaviour}
With most entities represented as smart pointer, the need to ensure a leak free simulator nevertheless remained. To check for allocation misuse and a whole other series of errors we used Valgrind \cite{}. This meant for example that we detected a leak caused by circularly referenceing smart pointers.

\chapter{Functionality}
\section{Paradigms}
\subsection{Classic}
\subsection{Coupled}
\subsection{Dynamic Structured}
\subsection{Parallel}
\subsubsection{Optimistic}
Optimistic time synchronization requires an implementation of timewarp, and more extensive locking than would be required for conservative. The GVT algorithm (Mattern \cite{Mattern}) runs on a separate thread from the simulation kernel threads, so care must taken that they don't deadlock, but don't race either.
\subsubsection{Conservative}


\chapter{Obstacles}
\section{Virtualization}
Virtualization proved a significant hurdle by exposing potential faults. Standard compliant code was found to be leaking memory by not calling container member destructors but only on a VM with Linux as Guest and Windows as Host. This was never reprodicible in another setting.
\section{Operating System differences}
\section{Threading}
G++'s std::string implementation appears to be still COW, triggering an alert by threadsanitizer for a possible race whenever a string was supposedly copied but internally still stored as a reference to the same object. Explicitly invoking the string constructor with the char[] proved to be a safe workaround here. Note that this problem is a known issue \cite{cow}
\section{Toolchains}
To develop we used the required toolchains. 
\section{Logger}
The recommended logger (g3log), while powerful and fast, proved a dead end since it does not compile on cygwin. 
Stijn therefore wrote his own implementation. %TODO Stijn
\chapter{Performance Analysis}
Whenever we made big design/architecture decisions, we first wrote some prototyping testcode to prove the viability (e.g. Network, Tracing, Logger).
\chapter{Conclusion}

\chapter{Appendix}

\begin{thebibliography}{1}


  \bibitem{cow} \url{https://gcc.gnu.org/bugzilla/show_bug.cgi?id=21334#c47}

  \bibitem{Mattern} \url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.111.2811}

  \end{thebibliography}
\end{document}