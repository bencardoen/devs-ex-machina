\lstset{
    frameround=fttt,
    language=C++,
    breaklines=true,
}

\section{Time}
Time is a very important aspect of the simulator. Our implementation allows users to easily change the representation of time in order to fit their needs.
\paragraph{Custom time object}
You can change how time is represented by changing the \lstinline{t_timestamp} type definition in the \path{src/forwarddeclare/timestamp.h} header. Please take care that this type implements at least the interface provided by the default \lstinline{Time} class. For more information, take a look at the accompanying documentation.

\section{Tracing}
\label{sec:Tracing}
The tracers generate output during the simulation. The default set of tracers will print verbose output to the standard output stream \lstinline{std::cout}.
\paragraph{Custom set of tracers}
If the default set of tracers is not satisfactory, then you can select your own set of tracers. The header \path{tracers.h} in the folder \path{src/forwarddeclare} contains the typedef for the default implementation.
\begin{lstlisting}
typedef Tracers<VerboseTracer<CoutWriter>> t_tracerset;
\end{lstlisting}
You can select as many tracers as you want by providing more template arguments. The following example sets the simulator to use two tracers. The first tracer will generate the default verbose output and write it to a file. The second tracer is a custom tracer.
\begin{lstlisting}
typedef Tracers<VerboseTracer<FileWriter>,
                MyTracer> t_tracerset;
\end{lstlisting}
Note that some tracers might need special initialization prior to use, such as the tracers provided by us that make use of the \lstinline{FileWriter} policy.

\paragraph{Provided Tracers}
All provided tracers make use of the policy pattern to separate the output generation from sending that output to an output sink. Currently, there is a policy for sending the output directly to standard out (\lstinline{CoutWriter}) or writing it to a file(\lstinline{FileWriter}) or multiple files (\lstinline{MultiFileWriter}). All three policies can be found in the \path{src/tracers/policies.h} header. Note that in the case of \lstinline{FileWriter} and \lstinline{MultiFileWriter}, the tracer must be explicitly initialized before it can be used. For more details, refer to the provided documentation.\\
Currently, the simulator provides four tracer classes:
\begin{itemize}
	\item \emph{VerboseTracer} Generates verbose output that is comparable to the verbose output of the Python PDEVS implementation by Jentl Van Tendeloo.
	\item \emph{XMLTracer} The XML output generated by this tracer adheres to the format expected by the DEVS Trace Plotter by Hongyan (Bill) Song.
	\item \emph{JSonTracer} The structure of the generated JSON is derived from the XML format.
	\item \emph{CellTracer} The cell tracer is useful for creating output resembling a map or grid. It requires the models to derive from the \lstinline{CellAtomicModel} model class (see earlier). The cell tracer is the only tracer that fully supports the \lstinline{MultiFileWriter} policy.
\end{itemize}

\paragraph{Implementing a custom tracer}
\subparagraph{The tracing interface}
The custom tracer must at least implement the following interface:
\begin{lstlisting}
interface Tracer
{
public:
  /**
   * @brief Traces state initialization of a model
   * @param model The model that is initialized
   * @param time The simulation time of initialization.
   */
  void tracesInit(const t_atomicmodelptr& adevs,
                  t_timestamp time);

  /**
   * @brief Traces internal state transition
   * @param adevs The atomic model that just
   *              performed an internal transition
   * @precondition The model pointer is not a nullptr
   */
  void tracesInternal(const t_atomicmodelptr& adevs,
                      std::size_t coreid);

  /**
   * @brief Traces external state transition
   * @param model The model that just went
   *              through an external transition
   */
  void tracesExternal(const t_atomicmodelptr& adevs,
                      std::size_t coreid);

  /**
   * @brief Traces confluent state transition
   * A confluent state transition is
   * a simultaneous internal and external transition.
   * @param model The model that just went
   *              through a confluent transition
   */
  void tracesConfluent(const t_atomicmodelptr& adevs,
                       std::size_t coreid);

  /**
   * @brief Traces the  start of the output
   * Certain tracers can use this to generate a header or similar
   */
  void startTrace();
  
  /**
   * @brief Finishes the trace output
   * Certain tracers can use this to generate a footer or similar
   */
  void finishTrace();
};
\end{lstlisting}
Even though it is not explicitly enforced, it is highly recommended to allow the use of output policies. Certain functions used by the simulator are provided by the policy and not by the tracer. See the section \emph{Implementing a custom output policy} for more details.\\
Note that the tracer must not print its output upon generation. To make sure that the output is still generated in the correct order, the tracer must register a \lstinline{TraceMessage}.
\subparagraph{Registering a trace message}
The \lstinline{TraceMessage} class is defined in the \path{src/tracers/tracemessage.h} header file. These messages allow the simulator to schedule output generation and purge unwanted messages upon rollback. They contain the following elements:
\begin{itemize}
	\item[timestamp] The time upon which this message is created. This time can be retrieved either from the model that is being traced or as a separate parameter.
	\item[execute function] This function is executed when the trace output can be safely sent to an output sink. It is recommended to use \lstinline{std::bind<...>()}. The function must be of type \lstinline{void()}.
	\item[coreID] Each simulation core has an ID. During the simulation, it can happen that some trace messages must be removed based on which core initiated the trace.
	\item[delete function] This function is called when the \lstinline{TraceMessage} is destructed. If the tracer must allocate memory on the heap, this function can be used to free that memory.\\*
		Just like the \emph{execute function}, this function must be of type \lstinline{void()}.
\end{itemize}
When the message is created, it can be scheduled with the free function \lstinline{void scheduleMessage(t_tracemessageptr message)}.\\
Both the \lstinline{TraceMessage} class and the \lstinline{scheduleMessage} function are defined in the \path{src/tracers/tracemessage.h} header. For a more in-depth example, you can always take a look at the implementation of the \lstinline{VerboseTracer} or the \lstinline{CellTracer}.

\paragraph{Implementing a custom output policy}
All policies only implement a handful of functions. This is the interface that all policies are expected to implement:
\begin{lstlisting}
class CustomPolicy
{
public:
  /**
   * @brief Stops the tracer from writing the output.
   * @warning	We assume that this function is not
   *   called while a simulation is in progress.
   *   If there is, we can make no guarantee when
   *   the output generation actually stops.
   * @note  When you implement a custom tracer
   *   that doesn't use policies, it must
   *   implement this function as well.
   */
	void stopTracer();

  /**
   * @brief Restarts the tracer.
   * @param recover Whether or not the new output should
   *   be appended to the old output or not,
   *   if applicable.
   * @note  When you implement a custom tracer
   *   that doesn't use policies, it must
   *   implement this function as well.
   */
	void startTracer(bool recover);
	
protected:
  /**
   * @brief Default Constructor for this policy.
   * All policies should have a default constructor.
   */
	CustomPolicy();

  /**
   * @brief Prints the data to the output sink.
   *
   * The data can have any type, as long as the proper
   * output operator has been defined.
   * This function is called whenever tracing output
   * should be written to the output sink.
   *
   * @param data... These objects will be printed
   *                to the output sink.
   * @precondition The output operator << is specified
   *  for printing each and every data object
   *  to an std::ofstream.
   */
	template<typename ... Args>
	inline void print(const Args&... args);
};
\end{lstlisting}
Some policies may need initialization. Initializing the policy should happen in a separate \lstinline{initialize} member function. Examples of policies that use such a function are \lstinline{FileWriter} and \lstinline{MultiFileWriter}.