Several \textsf{DEVS} simulation tools have already been implemented, which bear some similarity to our simulation tool.
We discuss several dimensions of related work, as we try to compromise between different tools.

In terms of code design and philosophy, dxex is most related to PythonPDEVS~\cite{PythonPDEVS}.
Performance of PythonPDEVS was still decent, through the use of simulation and activity hints from the modeller.
This allowed the kernel to optimize its internal data structures and algorithms for the specific model being executed.
All changes were completely transparant to the model itself, and were completely optional.
In this spirit, we now offer users the possibility to chose between different synchronization protocols.
This allows them to chose for the most appropriate synchronization, depending on the actual model being simulated.
Contrary to PythonPDEVS, however, dxex doesn't support activity hints.

While PythonPDEVS offers very fast turnaround cycles, due to the use of an interpreted language, simulation performance was easily outdone by compiled simulation kernels.
In terms of performance, adevs~\cite{adevs} offers faster simulation, at the cost of a significant compilation time.
The turnaround cycle in adevs is much slower though, specifically because the complete simulation kernel is implemented using templates, and thus in header files.
This prevents use of the simulation kernel as a shared library.
A similar compilation cycle is seen in PowerDEVS~\cite{PowerDEVS}.
As a result, the complete simulation kernel has to be compiled again everytime.
Dxex compromises, as was the case in other compiled simulation kernels, such as vle~\cite{vle}, by seperating the simulation kernel into a shared library.
After the initial compilation of the simulation tool, only the model has to be compiled and linked to the library.
This significantly shortens the turnaround cycle, while still offering good performance
In terms of performance, it therefore comes close to, and sometimes beats, adevs.
While a more extensive set of benchmarks is required to make accurate comparisons, initial results are promising.
Despite its high performance, adevs does not support optimistic synchronization, which we have shown to be highly relevant.

Previous \textsf{DEVS} simulation tools have already implemented multiple synchronization protocols, though mostly in an ad-hoc way.
For example CD++~\cite{CD++} has both a conservative (CCD++~\cite{CCD++}) and optimistic (PCD++)~\cite{PCD++}) variant.
Despite the implementation of both, they are different projects entirely, and while they might support a similar set of features, they remain different from each other.
Dxex, on the other hand, is a single project, where switching between different synchronization protocols is as simple as switching any other configuration parameter.

In summary, dxex tries to find the middle ground between the concepts of PythonPDEVS, the performance of adevs, and the multiple synchronization protocols of CD++.
