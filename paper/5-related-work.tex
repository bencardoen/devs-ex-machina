%TODO explain about other DEVS simulation kernels, and how they differ
%TODO explain about PythonPDEVS, the most related in terms of feature and "legacy" --> now in C++11 and way better performance
\subsection{PythonPDEVS}
Dxex is closely related to PyPDEVS in design and philosophy. PyPDEVS allows anyone who grasps the PDEVS formalisms to immediately simulate his/her model without having to consider the kernel implementation. A Python based implementation offers the advantage of very fast prototype/run/evaluate cycles, this can't be matched by a C++ simulator. It should be noted that, once the kernels have been compiled (in shared libraries), the actual compilation time of the model is small enough to make prototyping possible.
Advanced features such as activity based relocation and the performance gains this results in, are still unique to PyPDEVS.
\subsection{Adevs}
%TODO explain about adevs, the most related in terms of performance --> we implement more synchronization options and offer better performance because ...
Adevs is still under active development, allowing for an exact comparison in performance and features. It remains a very fast simulation engine for the PDEVS formalism, but it lacks an optimistic synchronization implementation. %Tracing ?
Due to the fact that adev does not flatten the Coupled Models, it's performance degrades significantly if the hierarchy becomes deeper. Dxex, on the other hand, manages lookahead with more overhead than adevs, leading to a performance difference as the model count increases. Finally, adevs employs the full dependency graph this in contrast with dxex kernels, which only observe 1-edge removed nodes. 
%checkme
\subsection{CD++}
%TODO explain about CD++, the most related in terms of synchronization --> we implement everything in a single program, with a non-fragmented code-base
%TODO make mention of Warped, which is the kernel used in CD++, and why we don't use it
Different projects on CD++ offer conservative (CCD++) as well as optimistic (PCD++) parallel simulation. In contrast to dxex,  neither projects offer both synchronization protocols. CD++ relies on the WARPED kernel. It is a middleware that provides memory, event, file, time and communication scheduling. We did not use the WARPED kernel (nor the underlying MPI) because dxex is designed specifically for a shared memory architecture and, as such, any middleware, however feature-rich, would have lead to an unacceptable overhead.
