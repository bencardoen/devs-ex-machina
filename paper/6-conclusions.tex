

\section{Future work}
%TODO future work: more things that we might want to implement, and probably something about automatically switching between synchronization protocols at runtime (and reference my activity papers ;))
\subsection{Memory}
Our optimistic implementation can benefit from a faster GVT algorithm such
 as used in~\cite{Fujimoto:1997:CGV:268403.268404}  or, more recently in~\cite{Bauer:2005:SND:1069810.1070159}. 
With access to the memory subsystem already in place (pools), the optimistic case could be constrained using per kernel quota, preventing the simulation from exhausting memory. While less sensitive to memory pressure, the same approach could improve the conservative case.
\subsection{Activity}
As shown in~\cite{PythonPDEVS_ACTIMS}, activity and allocation of models across kernels is a key aspect in achieving high performance in any parallel implementation. Allocating models so that there are no dependency cycles between their containing kernels is a first step, but not always possible. For the optimistic case, one can use re-allocation to break (runtime dependency) cycles and/or perform load-balancing. If kernels are unevenly balanced, they will begin to drift fast, causing increasingly more reverts. In dxex, we implement a limited framework to track model activity for debugging purposes; this could be extended to enable the above strategies.
\subsection{Hybrid}
The optimistic implementation could use (null/eot/eit) from the conservative case to detect and/or reduce the cost of reverts without completely stalling on influencing kernels.\\
The eot calculation in the conservative case can be enhanced by using the entire dependency graph between kernels (not models). The implementation could detect dependency cycles between kernels and, instead of waiting on dependent kernels, advance as a synced group with better scaling. LBTS calculation could leverage this as well to reduce memory usage, though this is not that stringent in the conservative case.
Ultimately, the simulation could switch at runtime between protocols based on the information provided by activity tracking. This requires the above mentioned framework, and can only be done at timepoints where a GVT/LBTS time is agreed upon between the kernels. From the model's perspective, no changes are needed, although a non-trivial lookahead is obviously desired. 

\section{CONCLUSIONS}
%TODO conclude the paper, saying that our new simulation tool offers conservative and optimistic synchronization, resulting in good performance, which is even better than adevs
In this paper, we presented dxex, a new C++-based PDEVS implementation supporting both sequential and parallel processing models.\\
We showed that, in the sequential case, dxex outperforms adevs in hierarchical simulations and that adevs produces better results in broadcast-like simulations.\\
In the parallel case, the results are more subtle. The sensitivity to broadcast simulations is carried over in the parallel implementation, resulting in performance loss for both synchronization protocols. The optimistic case can still achieve good performance if the volume of inter-kernel messages is low. Both synchronization protocols are fast in non-cyclic simulations, whereas the conservative case is better suited whenever state-saving becomes expensive; the optimistic case, on the other hand, is better suited when a lookahead is not available.
Finally, the current optimistic implementation is ill-suited for memory constrained systems, especially in simulations where the frequency of reverts is high.
