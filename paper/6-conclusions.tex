%TODO conclude the paper, saying that our new simulation tool offers conservative and optimistic synchronization, resulting in good performance, which is even better than adevs
Sequentially dxex outperforms adevs in hierarchical simulations while yielding to adevs in broadcast-like simulations. 
Parallel the results are more nuanced. The sensitivity to broadcast simulations is carried over in the parallel implementation, resulting in performance loss for both synchronization protocols. Optimistic can still achieve good performance if the volume of inter-kernel messages is low. Both  are fast in non-cyclic simulations, with conservative better suited whenever state-saving becomes expensive and optimistic when lookahead is not available.\\
Finally, the current optimistic implementation is ill-suited for memory constrained systems, especially in simulations where the frequency of reverts is high.
\subsection{Future work}
%TODO future work: more things that we might want to implement, and probably something about automatically switching between synchronization protocols at runtime (and reference my activity papers ;))
\subsubsection{Memory}
Our optimistic implementation can benefit from a faster GVT algorithm such as FujiMoto's \cite{Fujimoto:1997:CGV:268403.268404} or more recently \cite{Bauer:2005:SND:1069810.1070159}. 
With access to the memory subsystem in place (pools), optimistic could be constrained using per kernel quota preventing the simulation from exhausting memory. While less sensitive to memory pressure, the same approach could benefit conservative.
\subsubsection{Activity}
As shown in \cite{PythonPDEVS_ACTIMS} activity and allocation of models across kernels is a key aspect in achieving high performance in any parallel implementation. Allocating models so that there are no dependency cycles between their containing kernels is a first step, but not always possible. For optimistic one can use re-allocation to break (runtime dependency) cycles and/or perform load-balancing. If kernels are unevenly balanced they will begin to drift fast, causing increasingly more reverts. There is a limited framework implemented to track model activity for debugging purposes, this could be extended to enable the above strategies.
\subsubsection{Hybrid}
The optimistic implementation could use (null/eot/eit) from conservative to detect and/or reduce the cost of reverts without completely stalling on influencing kernels.
Conservative kernels could be extended with runtime information about influencing models, for example if one can guarantee a static dependency is not used for a fixed time-span, this can be removed for that period of (virtual) time. 
Ultimately the simulation could switch at runtime between protocols based on the information provided by activity tracking. This requires the above mentioned framework, and could only be done at timepoints where a GVT/LBTS time is agreed upon between the kernels. From the model point of view no changes are needed, although a non-trivial lookahead is obviously desired. 
